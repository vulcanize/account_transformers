module.exports=function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},r.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r.w={},r(r.s=7)}([function(e,t){e.exports=require("debug")},function(e,t){e.exports=require("ws")},function(e,t){e.exports=require("http")},function(e,t){e.exports=require("subscriptions-transport-ws")},function(e,t){e.exports=require("lodash/mapKeys")},function(e,t){e.exports=require("events")},function(e,t){e.exports=require("graphql-subscriptions")},function(e,t,r){"use strict";r.r(t);var n=r(6),o=r(5),i=r(0),s=r.n(i),a=r(4),c=r.n(a),l=r(3),u=r(2);const p=s()("graphile-build-pg:subscriptions"),d=e=>(e=>new Buffer(String(e)).toString("base64"))(JSON.stringify(e));var f=function(e,{pubsub:t,pgSubscriptionPrefix:r="postgraphile:",pgSubscriptionAuthorizationFunction:n}){if(!t)return void p("Subscriptions disabled - no pubsub provided");const o={listen:()=>"listen",listenPayload:()=>"ListenPayload"};e.hook("build",e=>e.inflection?e.extend(e,{inflection:e.extend(e.inflection||{},{listen:()=>"listen",listenPayload(){return this.upperCamelCase(`${this.listen()}-payload`)}})}):e),e.hook("GraphQLObjectType:fields",(e,i,{scope:{isRootSubscription:s},fieldWithHooks:a})=>{const{extend:c,newWithHooks:l,pgSql:u,graphql:{GraphQLObjectType:f,GraphQLNonNull:h,GraphQLString:b,GraphQLID:g},getTypeByName:m,$$isQuery:w,pgParseIdentifier:y,resolveNode:S}=i;if(!s)return e;const v=n?y(n):null,q=m("Node"),P=m("Query"),x=i.inflection||o,O=l(f,{name:x.listenPayload(),fields:()=>Object.assign({},{query:{description:"Our root query field type. Allows us to run any query from our subscription payload.",type:P,resolve:()=>w}},q?{relatedNode:a("relatedNode",({getDataFromParsedResolveInfoFragment:e})=>({type:q,resolve:async(t,r,n,o)=>t.relatedNodeId?await S(t.relatedNodeId,i,{getDataFromParsedResolveInfoFragment:e},{},n,o):null}),{isPgGenericSubscriptionPayloadRelatedNodeField:!0}),relatedNodeId:{type:g}}:null)},{isPgGenericSubscriptionPayloadType:!0}),_=x.listen();return c(e,{[_]:a(_,()=>({type:new h(O),args:{topic:{type:new h(b)}},subscribe:async(e,n,o,i)=>{const{pgClient:s}=o,a=(r||"")+n.topic;let c;if(v){const{text:e,values:t}=u.compile(u.query`select unsubscribe_topic from ${u.identifier(v.namespaceName,v.entityName)}(${u.value(a)}) unsubscribe_topic`),{rows:[[r]]}=await s.query({text:e,values:t,rowMode:"array"});if(!r)throw new Error("You may not subscribe to this topic");c=r}const l=t.asyncIterator(a);if(c){const e=t.asyncIterator(c);e.next().then(()=>{p("Unsubscribe triggered on channel %s",c),l.return(),e.return()})}return l},resolve:async(e,t,r,n)=>{const o={};if(q&&e&&e.__node__){const t=d(e.__node__);o.relatedNodeId=t}return o}}),{isPgGenericSubscriptionRootField:!0})})})},h=r(1);function b(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},n=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(n=n.concat(Object.getOwnPropertySymbols(r).filter(function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable}))),n.forEach(function(t){g(e,t,r[t])})}return e}function g(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}r.d(t,"enhanceHttpServerWithSubscriptions",function(){return v});const m=s()("postgraphile:subscriptions");let w,y,S=!1;t.default={init(e,{version:t,graphql:r}){if(!S){S=!0;const e=t.split(".");if(parseInt(e[0],10)<4)throw new Error(`Unsupported version ${t}`);if(!r)throw new Error("Incompatible version of PostGraphile; 'graphql' not available on 'check' hook.");({execute:w,subscribe:y}=r)}},"cli:flags:add:schema":e=>(e("-S, --simple-subscriptions","⚡️[experimental] add simple subscription support"),e("--subscription-authorization-function [schemaDotFunctionName]","⚡️[experimental] PG function to call to check user is allowed to subscribe"),e),"cli:library:options"(e,{config:t,cliOptions:r}){const{simpleSubscriptions:n=!1,subscriptionAuthorizationFunction:o=null}=b({},t.options,r);return b({},e,{simpleSubscriptions:n,subscriptionAuthorizationFunction:o})},"postgraphile:middleware"(e,{options:t}){let r=!1;const n=(...n)=>{if(!r){r=!0;const[o,i,s]=n;let a;if("function"==typeof i){const[e,t]=[o,i];a=e.req}else if("function"==typeof s){const[e,t,r]=[o,i,s];a=e}else{const[e,t]=[o,i];a=e}const c=a&&a.connection&&a.connection.server;c?v(c,e,t):console.warn("Failed to find server to add websocket listener to, you'll need to call `enhanceHttpServerWithSubscriptions` manually")}return e(...n)};return Object.assign(n,e),n},"cli:server:created"(e,{options:t,middleware:r}){const{simpleSubscriptions:n}=t;return n&&r.getGraphQLSchema&&v(e,r,t),e},"cli:greeting"(e,{options:t,port:r,chalk:n,middleware:o}){const{graphqlRoute:i,host:s="localhost",simpleSubscriptions:a}=t;return[...e,"🙏 Thank you for supporting PostGraphile! 🙏",a&&o.getGraphQLSchema?`Subscriptions support enabled at ${n.underline(`ws://${s}:${r}${i}`)}`:null]},"postgraphile:options"(e,{pgPool:t}){if(!S)throw new Error("To use this plugin you must upgrade to PostGraphile 4.0.0-rc.3 or higher");const r=new o.EventEmitter,{simpleSubscriptions:i,subscriptionAuthorizationFunction:s}=e,a=i&&new n.PubSub({eventEmitter:r});if(a){const n=a,o=function(e){let t;if(e.payload)try{t=JSON.parse(e.payload)}catch(e){m("Failed to parse payload JSON"),m(e)}n.publish(e.channel,t)};let i;const c=function(){i&&i.removeListener("notification",o),i=null},l=function(e,t){const r="LISTEN "+e.escapeIdentifier(t);return e.query(r).then(()=>null)},u=function(e,t){const r="UNLISTEN "+e.escapeIdentifier(t);return e.query(r).then(()=>null)},p={},d=function(e){p[e]=(e[e]||0)+1,1===p[e]&&i&&l(i,e)},h=function(e){p[e]=(e[e]||1)-1,0===p[e]&&i&&u(i,e)},g=r.addListener;r.addListener=function(e,t){return d(e),g.call(this,e,t)};const w=r.removeListener;r.removeListener=function(e,t){return h(e),w.call(this,e,t)};const y=async function(){let e;try{e=await t.connect()}catch(e){return void setTimeout(y,1e3)}(i=e).addListener("notification",o);const r=Object.entries(p).filter(([e,t])=>t>0).map(([e])=>e);try{await Promise.all(r.map(t=>l(e,t)))}catch(e){c(),y()}};return y(),t.on("remove",e=>{e===i&&(c(),t.ending||y())}),b({},e,{graphileBuildOptions:b({},e.graphileBuildOptions,{pubsub:a,pgSubscriptionAuthorizationFunction:s}),appendPlugins:[...e.appendPlugins||[],f]})}return e},withPostGraphileContext:e=>async(t,r)=>{if(t.singleStatement){const n={query(r,n,o){if(r&&"object"==typeof r){if(n||o)throw new Error("Incompatible call to singleStatement - expected no callback")}else{if("string"!=typeof r)throw new Error("Incompatible call to singleStatement - bad query");if(n&&"object"!=typeof n)throw new Error("Incompatible call to singleStatement - bad values");if(o)throw new Error("Incompatible call to singleStatement - expected to return promise")}return e(b({},t,{singleStatement:!1}),({pgClient:e})=>e.query(r,n))}};return await r({pgClient:n})}return e(t,r)}};async function v(e,t,r){if(!w)throw new Error("The plugin must be initialised before you call enhanceHttpServerWithSubscriptions.");if(e.__postgraphileSubscriptionsEnabled)return;e.__postgraphileSubscriptionsEnabled=!0;const{getGraphQLSchema:n,formatError:o,withPostGraphileContextFromReqRes:i}=t,s=r.graphqlRoute||"/graphql",a=await n(),p=r.handleErrors||(e=>e.map(o)),d={},f=e=>{const t=d[e];t&&t.resolve()},b=(e,t)=>{f(t);const r=(()=>{let e,t;const r=new Promise((r,n)=>{e=r,t=n});return r.resolve=e,r.reject=t,r})();return r.context=e,d[t]=r,r},g=async e=>{const{__postgraphileReq:t}=e;if(!t)throw new Error("req could not be extracted");let n=e.__postgraphileRes;if(t.res)throw new Error("Please get in touch with Benjie; we weren't expecting req.res to be present but we want to reserve it for future usage.");return n||((n=new u.ServerResponse(t)).writeHead=(t=>{t&&t>200&&(console.error(`Something used 'writeHead' to write a '${t}' error for websockets - check the middleware you're passing!`),e.close())}),await(async(e=[],t,r)=>{for(const n of e)await new Promise((e,o)=>{n(t,r,t=>t?o(t):e())})})(r.websocketMiddlewares||r.middlewares,t,n),e.__postgraphileRes=n),{req:t,res:n}},m=new h.Server({noServer:!0});e.on("upgrade",(e,t,r)=>{(e.originalUrl||e.url)===s&&m.handleUpgrade(e,t,r,t=>{m.emit("connection",t,e)})});const S=l.SubscriptionServer.create({schema:a,execute:w,subscribe:y,onConnect(e,t,r){const{socket:n,request:o}=r;if(n.__postgraphileReq=o,!o)throw new Error("No request!");n.postgraphileHeaders=Object.assign({},c()(e,(e,t)=>t.toLowerCase()),n.upgradeReq.headers)},async onOperation(e,t,r){const o=e.id,s=await((e,t)=>new Promise((r,n)=>{g(e).then(({req:e,res:n})=>i(e,n,{singleStatement:!0},e=>{const n=b(e,t);return r(n.context),n})).then(null,n)}))(r,o);S.schema=await n(),Object.assign(t.context,s);const{req:a,res:c}=await g(r);return t.formatResponse=((e,t)=>(e.errors&&(e.errors=p(e.errors,a,c)),e)),t},onOperationComplete(e,t){f(t)}},m)}}]);